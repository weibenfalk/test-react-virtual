import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function useScroll(ref, onChange) {
  var onChangeRef = React.useRef();
  onChangeRef.current = onChange;
  React.useEffect(function () {
    var el = ref.current;

    var handler = function handler(e) {
      onChangeRef.current({
        scrollLeft: e.target.scrollLeft,
        scrollTop: e.target.scrollTop
      });
    };

    if (el) {
      el.addEventListener('scroll', handler, {
        capture: false,
        passive: true
      });
      return function () {
        el.removeEventListener('scroll', handler);
      };
    }
  }, [ref]);
}

var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];

var rectChanged = function rectChanged(a, b) {
  if (a === void 0) {
    a = {};
  }

  if (b === void 0) {
    b = {};
  }

  return props.some(function (prop) {
    return a[prop] !== b[prop];
  });
};

var observedNodes = /*#__PURE__*/new Map();
var rafId;

var run = function run() {
  var changedStates = [];
  observedNodes.forEach(function (state, node) {
    var newRect = node.getBoundingClientRect();

    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function (state) {
    state.callbacks.forEach(function (cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run);
};

function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;

      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: undefined,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }

      if (wasEmpty) run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);

      if (state) {
        // Remove the callback
        var index = state.callbacks.indexOf(cb);
        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference

        if (!state.callbacks.length) observedNodes["delete"](node); // Stop the loop

        if (!observedNodes.size) cancelAnimationFrame(rafId);
      }
    }
  };
}

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

function useRect(nodeRef, observe, onChange) {
  if (observe === void 0) {
    observe = true;
  }

  var _React$useState = React.useState(),
      rerender = _React$useState[1];

  var _React$useState2 = React.useState(null),
      rect = _React$useState2[0],
      setRect = _React$useState2[1];

  var initialRectSet = React.useRef(false);
  var onChangeRef = React.useRef(null);
  onChangeRef.current = onChange;
  var element = nodeRef.current;
  useIsomorphicLayoutEffect(function () {
    if (!element) {
      requestAnimationFrame(function () {
        rerender({});
      });
    }

    var observer;

    if (element) {
      observer = observeRect(element, function (rect) {
        onChangeRef.current && onChangeRef.current(rect);
        setRect(rect);
      });
    }

    if (element && !initialRectSet.current) {
      initialRectSet.current = true;
      setRect(element.getBoundingClientRect());
    }

    observer && observer.observe();
    return function () {
      observer && observer.unobserve();
    };
  }, [element, observe, onChange]);
  return rect;
}

function useVirtual(_ref) {
  var _ref3, _measurements2;

  var _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0 : _ref$size,
      estimateSize = _ref.estimateSize,
      _ref$overscan = _ref.overscan,
      overscan = _ref$overscan === void 0 ? 0 : _ref$overscan,
      parentRef = _ref.parentRef,
      horizontal = _ref.horizontal,
      scrollToFn = _ref.scrollToFn;
  var sizeKey = horizontal ? 'width' : 'height';
  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';
  var defaultScrollToFn = React.useCallback(function (offset) {
    parentRef.current[scrollKey] = offset;
  }, [parentRef, scrollKey]);
  scrollToFn = scrollToFn || defaultScrollToFn;

  var _ref2 = useRect(parentRef) || (_ref3 = {}, _ref3[sizeKey] = 0, _ref3),
      outerSize = _ref2[sizeKey];

  var _React$useState = React.useState(0),
      scrollOffset = _React$useState[0],
      _setScrollOffset = _React$useState[1];

  useScroll(parentRef, function (_ref4) {
    var newScrollOffset = _ref4[scrollKey];

    _setScrollOffset(newScrollOffset);
  });
  var scrollOffsetPlusOuterSize = scrollOffset + outerSize;

  var _React$useState2 = React.useState({}),
      measuredCache = _React$useState2[0],
      setMeasuredCache = _React$useState2[1];

  var mountedRef = React.useRef();
  useIsomorphicLayoutEffect(function () {
    if (mountedRef.current) {
      if (estimateSize || size) setMeasuredCache({});
    }

    mountedRef.current = true;
  }, [estimateSize, size]);
  var measurements = React.useMemo(function () {
    var measurements = [];

    for (var i = 0; i < size; i++) {
      var _measurements;

      var _start = ((_measurements = measurements[i - 1]) == null ? void 0 : _measurements.end) || 0;

      var _size = measuredCache[i] || estimateSize(i);

      var _end = _start + _size;

      measurements[i] = {
        index: i,
        start: _start,
        size: _size,
        end: _end
      };
    }

    return measurements;
  }, [estimateSize, measuredCache, size]);
  var totalSize = ((_measurements2 = measurements[size - 1]) == null ? void 0 : _measurements2.end) || 0;
  var start = React.useMemo(function () {
    return measurements.find(function (rowStat) {
      return rowStat.end >= scrollOffset;
    });
  }, [measurements, scrollOffset]);
  var end = React.useMemo(function () {
    return [].concat(measurements).reverse().find(function (rowStat) {
      return rowStat.start <= scrollOffsetPlusOuterSize;
    });
  }, [measurements, scrollOffsetPlusOuterSize]);
  var startIndex = start ? start.index : 0;
  var endIndex = end ? end.index : 0; // Always add at least one overscan item, so focus will work

  startIndex = Math.max(startIndex - 1 - overscan, 0);
  endIndex = Math.min(endIndex + 1 + overscan, size - 1);
  var virtualItems = React.useMemo(function () {
    var virtualItems = [];

    var _loop = function _loop(i) {
      var measurement = measurements[i];

      var item = _extends(_extends({}, measurement), {}, {
        measureRef: function measureRef(el) {
          if (!el) return;

          var _el$getBoundingClient = el.getBoundingClientRect(),
              measuredSize = _el$getBoundingClient[sizeKey];

          if (measuredSize !== item.size) {
            setMeasuredCache(function (old) {
              var _extends2;

              return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[i] = measuredSize, _extends2));
            });
          }
        }
      });

      virtualItems.push(item);
    };

    for (var i = startIndex; i <= endIndex; i++) {
      _loop(i);
    }

    return virtualItems;
  }, [startIndex, endIndex, measurements, sizeKey]);
  var latestRef = React.useRef();
  latestRef.current = {
    outerSize: outerSize,
    scrollOffset: scrollOffset,
    scrollOffsetPlusOuterSize: scrollOffsetPlusOuterSize,
    totalSize: totalSize
  };
  var scrollToOffset = React.useCallback(function (offset, _temp) {
    var _ref5 = _temp === void 0 ? {} : _temp,
        _ref5$align = _ref5.align,
        align = _ref5$align === void 0 ? 'start' : _ref5$align;

    var _latestRef$current = latestRef.current,
        outerSize = _latestRef$current.outerSize,
        scrollOffset = _latestRef$current.scrollOffset,
        scrollOffsetPlusOuterSize = _latestRef$current.scrollOffsetPlusOuterSize,
        totalSize = _latestRef$current.totalSize;
    offset = Math.max(0, Math.min(offset, totalSize - outerSize));

    if (align === 'auto') {
      if (offset <= scrollOffset) {
        align = 'start';
      } else if (offset >= scrollOffsetPlusOuterSize) {
        align = 'end';
      } else {
        align = 'start';
      }
    }

    if (align === 'start') {
      scrollToFn(offset);
    } else if (align === 'end') {
      scrollToFn(offset - outerSize);
    } else if (align === 'center') {
      scrollToFn(offset - outerSize / 2);
    }
  }, [scrollToFn]);
  var getIndexOffset = React.useCallback(function (index, _temp2) {
    var _ref6 = _temp2 === void 0 ? {} : _temp2,
        _ref6$align = _ref6.align,
        align = _ref6$align === void 0 ? 'start' : _ref6$align;

    var measurement = measurements[index];

    if (!measurement) {
      return;
    }

    if (align === 'auto') {
      if (measurement.end >= scrollOffsetPlusOuterSize) {
        align = 'end';
      } else {
        align = 'start';
      }
    }

    var offset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;
    return offset;
  }, [measurements, scrollOffsetPlusOuterSize]);
  var scrollToIndex = React.useCallback(function (index, options) {
    var offset = getIndexOffset(index, options);

    if (typeof offset !== 'undefined') {
      scrollToOffset(offset, options);
    }
  }, [getIndexOffset, scrollToOffset]);
  return {
    virtualItems: virtualItems,
    totalSize: totalSize,
    getIndexOffset: getIndexOffset,
    scrollToOffset: scrollToOffset,
    scrollToIndex: scrollToIndex
  };
}

export { useVirtual };
//# sourceMappingURL=react-virtual.mjs.map
