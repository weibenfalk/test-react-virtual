{"version":3,"file":"react-virtual.production.min.js","sources":["../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useIsomorphicLayoutEffect.js","../src/useRect.js","../src/index.js","../src/useScroll.js"],"sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef, observe = true, onChange) {\n  const [, rerender] = React.useState()\n  const [rect, setRect] = React.useState(null)\n  const initialRectSet = React.useRef(false)\n  const onChangeRef = React.useRef(null)\n  onChangeRef.current = onChange\n\n  const element = nodeRef.current\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      requestAnimationFrame(() => {\n        rerender({})\n      })\n    }\n\n    let observer\n\n    if (element) {\n      observer = observeRect(element, function (rect) {\n        onChangeRef.current && onChangeRef.current(rect)\n        setRect(rect)\n      })\n    }\n\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      setRect(element.getBoundingClientRect())\n    }\n\n    observer && observer.observe()\n\n    return () => {\n      observer && observer.unobserve()\n    }\n  }, [element, observe, onChange])\n  return rect\n}\n","import React from 'react'\n\nimport useScroll from './useScroll'\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport function useVirtual({\n  size = 0,\n  estimateSize,\n  overscan = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      parentRef.current[scrollKey] = offset\n    },\n    [parentRef, scrollKey]\n  )\n\n  scrollToFn = scrollToFn || defaultScrollToFn\n\n  const { [sizeKey]: outerSize } = useRect(parentRef) || {\n    [sizeKey]: 0,\n  }\n\n  const [scrollOffset, _setScrollOffset] = React.useState(0)\n\n  useScroll(parentRef, ({ [scrollKey]: newScrollOffset }) => {\n    _setScrollOffset(newScrollOffset)\n  })\n\n  const scrollOffsetPlusOuterSize = scrollOffset + outerSize\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize, size])\n\n  const measurements = React.useMemo(() => {\n    const measurements = []\n    for (let i = 0; i < size; i++) {\n      const start = measurements[i - 1]?.end || 0\n      const size = measuredCache[i] || estimateSize(i)\n      const end = start + size\n      measurements[i] = {\n        index: i,\n        start,\n        size,\n        end,\n      }\n    }\n\n    return measurements\n  }, [estimateSize, measuredCache, size])\n\n  const totalSize = measurements[size - 1]?.end || 0\n\n  let start = React.useMemo(\n    () => measurements.find(rowStat => rowStat.end >= scrollOffset),\n    [measurements, scrollOffset]\n  )\n  let end = React.useMemo(\n    () =>\n      [...measurements]\n        .reverse()\n        .find(rowStat => rowStat.start <= scrollOffsetPlusOuterSize),\n    [measurements, scrollOffsetPlusOuterSize]\n  )\n\n  let startIndex = start ? start.index : 0\n  let endIndex = end ? end.index : 0\n\n  // Always add at least one overscan item, so focus will work\n  startIndex = Math.max(startIndex - 1 - overscan, 0)\n  endIndex = Math.min(endIndex + 1 + overscan, size - 1)\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n\n    for (let i = startIndex; i <= endIndex; i++) {\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (!el) return\n\n          const { [sizeKey]: measuredSize } = el.getBoundingClientRect()\n\n          if (measuredSize !== item.size) {\n            setMeasuredCache(old => ({\n              ...old,\n              [i]: measuredSize,\n            }))\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [startIndex, endIndex, measurements, sizeKey])\n\n  const latestRef = React.useRef()\n  latestRef.current = {\n    outerSize,\n    scrollOffset,\n    scrollOffsetPlusOuterSize,\n    totalSize,\n  }\n\n  const scrollToOffset = React.useCallback(\n    (offset, { align = 'start' } = {}) => {\n      const {\n        outerSize,\n        scrollOffset,\n        scrollOffsetPlusOuterSize,\n        totalSize,\n      } = latestRef.current\n\n      offset = Math.max(0, Math.min(offset, totalSize - outerSize))\n\n      if (align === 'auto') {\n        if (offset <= scrollOffset) {\n          align = 'start'\n        } else if (offset >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(offset)\n      } else if (align === 'end') {\n        scrollToFn(offset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(offset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const getIndexOffset = React.useCallback(\n    (index, { align = 'start' } = {}) => {\n      const measurement = measurements[index]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffsetPlusOuterSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      let offset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      return offset\n    },\n    [measurements, scrollOffsetPlusOuterSize]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (index, options) => {\n      const offset = getIndexOffset(index, options)\n      if (typeof offset !== 'undefined') {\n        scrollToOffset(offset, options)\n      }\n    },\n    [getIndexOffset, scrollToOffset]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    getIndexOffset,\n    scrollToOffset,\n    scrollToIndex,\n  }\n}\n","import React from 'react'\n\nexport default function useScroll(ref, onChange) {\n  const onChangeRef = React.useRef()\n  onChangeRef.current = onChange\n\n  React.useEffect(() => {\n    const el = ref.current\n\n    const handler = e => {\n      onChangeRef.current({\n        scrollLeft: e.target.scrollLeft,\n        scrollTop: e.target.scrollTop,\n      })\n    }\n\n    if (el) {\n      el.addEventListener('scroll', handler, {\n        capture: false,\n        passive: true,\n      })\n\n      return () => {\n        el.removeEventListener('scroll', handler)\n      }\n    }\n  }, [ref])\n}\n"],"names":["rafId","props","observedNodes","Map","run","changedStates","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","cb","window","React","useLayoutEffect","useEffect","useRect","nodeRef","observe","onChange","rerender","useState","setRect","initialRectSet","useRef","onChangeRef","current","element","useIsomorphicLayoutEffect","observer","requestAnimationFrame","wasEmpty","undefined","hasRectChanged","callbacks","unobserve","index","length","size","cancelAnimationFrame","estimateSize","overscan","parentRef","horizontal","scrollToFn","sizeKey","scrollKey","defaultScrollToFn","useCallback","offset","ref","outerSize","scrollOffset","_setScrollOffset","newScrollOffset","el","handler","e","scrollLeft","target","scrollTop","addEventListener","capture","passive","removeEventListener","scrollOffsetPlusOuterSize","measuredCache","setMeasuredCache","mountedRef","measurements","useMemo","i","start","end","totalSize","find","rowStat","reverse","startIndex","endIndex","Math","max","min","virtualItems","item","measureRef","measuredSize","old","push","latestRef","scrollToOffset","align","getIndexOffset","measurement","scrollToIndex","options"],"mappings":"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"}